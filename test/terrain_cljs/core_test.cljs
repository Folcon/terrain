(ns terrain-cljs.core-test
  (:require [clojure.test :as t :refer [deftest testing is]]
            [clojure.spec.alpha :as s]
            [clojure.spec.gen.alpha :as sgen]
            [clojure.test.check.clojure-test :refer [defspec]]
            [clojure.test.check.properties :as prop]
            [clojure.test.check.generators :as gen]
            [terrain-cljs.core :as core]
            ["d3" :as d3]
            ["d3-delaunay" :as delaunay]
            ["/js/terrain.js" :as terrain]
            ["/js/language.js" :as language]))


(comment
  (let [hm (.generateCoast terrain #js{:npts 4096 :extent (-> terrain .-defaultParams .-extent)})
        mesh (.-mesh hm)])
  (js-keys mesh))

(comment
  (.makeWord language (.makeRandomLanguage language) "city"))


;; --- makeSRNG
;; This is just a seeded pseudo-random number generator
;;
;; WARN: Be aware that the make-srng keeps it's state outside itself, so don't do this:
;;   (let [rand-1 (make-srng 1)
;;         rand-2 (make-srng 1)]
;;     ...)
(defn js-make-srng [start]
  (.makeSRNG terrain start))

(def seed (atom nil))

(defn next-rand-from-seed [seed]
  (let [x (* (Math/sin seed) 10000)]
    (- x (Math/floor x))))

(defn make-srng [start]
  (reset! seed start)
  (fn []
    (let [current @seed]
      (swap! seed inc)
      (next-rand-from-seed current))))

(deftest make-srng-test
  (testing "Check that make-srng = js-make-srng"
    (let [js-rand (js-make-srng 1)
          rand    (make-srng 1)]
      (is (= (repeatedly 100 js-rand)
             (repeatedly 100 rand))))))


;; --- runif
;; This effectively generates a random number between low and high to return true or false, used in conditionals
;;
;; TODO: Figure out a way to test this properly, at the moment I'd have to do some binding magic,
;;   so I made a functional version, less for this, and more for the general technique.
(defn js-runif [lo hi]
  (.runif terrain lo hi))

(defn js-run-if [rng lo hi]
  (.run_if terrain rng lo hi))

(defn run-if [rng low high]
  (+ low (* (rng) (- high low))))

(defn gen-rand-seq [make-srng-fn rand-fn n]
  (->
    (reduce
      (fn [[rng out] f]
        (let [r (f rng)]
          [rng (conj out (if (fn? r) (r) r))]))
      [(make-srng-fn 1) []]
      (repeat n rand-fn))
    (second)))

(deftest run-if-test
  (testing "Check that run-if = js-runif"
    (is (= (gen-rand-seq make-srng #(js-run-if % 0.5 1) 100)
           (gen-rand-seq make-srng #(run-if % 0.5 1)    100)))))


;; --- rnorm
;; This is creates a pair of random numbers, you call it once for the first and then again for the second
;;
;; TODO: Same as before, made a functional version
;; WARN: Be aware that js-make-rnorm and make-rnorm are subtly different, the clojure version's state is fully outside the function,
;;   whereas the js one isn't, so:
;;   - these are the same:
;;   ```
;;   [(let [clj-r (make-rnorm    (make-srng 1))]
;;      [(clj-r) (clj-r)])
;;    (let [js-r  (js-make-rnorm (make-srng 1))]
;;      [(js-r)  (js-r)])
;;    (let [clj-rng (make-srng 1)]
;;      [((make-rnorm clj-rng)) ((make-rnorm clj-rng))])]
;;   #_#_=>
;;   [[0.46296593520418794 0.6209115428284142]
;;    [0.46296593520418794 0.6209115428284142]
;;    [0.46296593520418794 0.6209115428284142]]
;;   ```
;;   - but this is not!
;;   ```
;;   (let [js-rng (make-srng 1)]
;;     [((js-make-rnorm js-rng)) ((js-make-rnorm js-rng))])
;;   #_#_=>                          v------  this second value is the next value generated by the above generators, for the js version,
;;   [0.46296593520418794 1.0456922800932489]   the function must be called twice as it still retains some internal state.
;;   ```
(defn js-rnorm []
  (.rnorm terrain))

(defn js-make-rnorm [rand]
  (.make_seeded_rnorm terrain rand))

(defn rng->z1+z2 [rng]
  (let [x1 0
        x2 0
        [x1 x2 w] (loop [x1 x1 x2 x2]
                    (let [w (+ (* x1 x1) (* x2 x2))]
                      (if (and (not (zero? w)) (< w 1))
                        [x1 x2 w]
                        (recur
                          (run-if rng -1 1)
                          (run-if rng -1 1)))))
        w (Math/sqrt (/ (* -2 (Math/log w)) w))
        z2-val (* x2 w)
        z1-va1 (* x1 w)]
    [z1-va1 z2-val]))

;; TODO: Look to remove atom
(def z2 (atom nil))
(defn make-rnorm [rng]
  (fn []
    (if-let [z2-val @z2]
      (do (reset! z2 nil)
          z2-val)
      (let [[z1-val z2-val] (rng->z1+z2 rng)]
        (do (reset! z2 z2-val)
            z1-val)))))

(defn gen-rand-seq-2 [make-srng-fn rand-fn n]
  (->
    (reduce
      (fn [[rng out] f]
        (let [r (f rng)]
          [rng (into out [(r) (r)])]))
      [(make-srng-fn 1) []]
      (repeat n rand-fn))
    (second)))

(deftest make-rnorm-test
  (testing "Check that make-rnorm = js-make-rnorm"
    (let [_ (reset! z2 nil)]
      (is (= (gen-rand-seq-2 make-srng js-make-rnorm 100)
             (gen-rand-seq-2 make-srng make-rnorm 100))))))


;; --- randomVector
;; This is creates a vector of random magnitude and direction
;;
;; TODO: Same as before, made a functional version
(defn js-random-vector1 [scale]
  (.randomVector terrain scale))

(defn js-random-vector [rand scale]
  (.random_vector terrain rand scale))

(defn random-vector [rng scale]
  [(* scale ((make-rnorm rng))) (* scale ((make-rnorm rng)))])

(deftest random-vector-test
  (testing "Check that random-vector = js-random-vector"
    (let [_ (reset! z2 nil)]
      (is (= (js->clj
               (gen-rand-seq make-srng #(js-random-vector % 4) 100))
             (gen-rand-seq make-srng #(random-vector % 4) 100))))))


;; --- generatePoints
;; This is creates bunch of randomly positioned points
;;
;; TODO: Same as before, made a functional version
(defn js-generate-points1 [n extent]
  (.generatePoints terrain n extent))

(defn js-generate-points [rand n extent]
  (.generate_points terrain rand n extent))

(def default-extent
  {:width  1
   :height 1})

(defn generate-points
  ([rng n] (generate-points rng n default-extent))
  ([rng n extent]
   (let [{:keys [width height]} extent]
     (into []
       (comp
         (partition-all 2)
         (map (fn [[x y]] [(* (- x 0.5) width) (* (- y 0.5) height)])))
       (repeatedly (* n 2) rng)))))

(deftest generate-points-test
  (testing "Check that generate-points = js-generate-points"
    (is (= (js->clj
             (js-generate-points (make-srng 1) 100 (clj->js default-extent)))
           (generate-points      (make-srng 1) 100 default-extent)))))


;; --- centroid
;; This computes the centroid of a bunch of points
;;
(defn js-centroid [pts]
  (.centroid terrain pts))

(defn centroid [points]
  (if-not (nil? points)
    (let [points (remove nil? points)
          size (count points)
          [sum-x sum-y]
          (reduce
            (fn [[x y] [point-x point-y]]
              [(+ x point-x)
               (+ y point-y)])
            [0 0]
            points)]
      [(/ sum-x size)
       (/ sum-y size)])
    points))

(deftest centroid-test
  (testing "Check that centroid = js-centroid"
    (let [points (generate-points (make-srng 1) 1000 {:width 100 :height 100})]
      (is (= (js->clj
               (js-centroid (clj->js points)))
             (centroid points))))))


;; --- voronoi
;; This takes a group of points and computes the voronoi
;;
;; WARN: voronoi returns a raw js object, you must use `extract-voronoi` to get the data for the moment
(defn js-voronoi [pts extent]
  (.voronoi terrain pts extent))

(defn voronoi
  ([points] (voronoi points default-extent))
  ([points extent]
   (let [{:keys [width height]} extent
         w (/ width 2)
         h (/ height 2)
         js-points (clj->js points)]
     (-> d3
       (.voronoi)
       (.extent (clj->js [[(- w) (- h)] [w h]]))
       (#(% js-points))))))

(defn extract-voronoi [voronoi-state]
  (let [edges     (.-edges voronoi-state)
        cells     (.-cells voronoi-state)
        links     (.links voronoi-state)
        polygons  (.polygons voronoi-state)
        triangles (.triangles voronoi-state)]
    {:edges (js->clj edges)
     :cells (js->clj cells :keywordize-keys true)
     :links (js->clj links :keywordize-keys true)
     :polygons  (js->clj polygons)
     :triangles (js->clj triangles)}))

(deftest voronoi-test
  (testing "Check that voronoi = js-voronoi"
    (let [extent {:width 100 :height 100}
          points (generate-points (make-srng 1) 1000 extent)]
      (is (= (extract-voronoi
               (js-voronoi (clj->js points) (clj->js extent)))
            (extract-voronoi
              (voronoi points extent)))))))


;; --- improve-points
;; This takes a group of points and relaxes them by computing the voronoi and then relocating the points to the dual circumcenter,
;;   `n` here refers to the number of rounds of relaxation to perform.
;;
(defn js-improve-points [pts n extent]
  (.improvePoints terrain pts n extent))

(defn improve-points
  ([points]   (improve-points points 1 default-extent))
  ([points n] (improve-points points n default-extent))
  ([points n extent]
   (let [improve (fn [js-points]
                   (->
                     (voronoi (js->clj js-points) extent)
                     (.polygons js-points)
                     (.map (comp clj->js centroid js->clj))))]
     (->
       (nth (iterate improve (clj->js points)) n)
       (js->clj)))))

(deftest improve-points-test
  (testing "Check that improve-points = js-improve-points"
    (let [extent    {:width 100 :height 100}
          js-extent (clj->js extent)
          points (generate-points (make-srng 1) 10 extent)]
      (is (= (js->clj
               (js-improve-points (clj->js points) 1 js-extent))
            (improve-points points 1 extent)))
      (is (= (js->clj
               (js-improve-points (clj->js points) 2 js-extent))
            (improve-points points 2 extent)))
      (is (= (js->clj
               (js-improve-points (clj->js points) 3 js-extent))
            (improve-points points 3 extent))))))


;; --- generate-good-points
;; This generates a group of 'good' points, basically by improving them for one round and sorting them. `n` is the number of points.
;;
;; TODO: Same as before, made a functional version
(defn js-generate-good-points1 [n extent]
  (.generateGoodPoints terrain n extent))

(defn js-generate-good-points [rand n extent]
  (.generate_good_points terrain rand n extent))

(defn generate-good-points
  ([rng n] (generate-good-points rng n default-extent))
  ([rng n extent]
   (let [points (sort (generate-points rng n extent))]
     (improve-points points 1 extent))))

(deftest generate-good-points-test
  (testing "Check that generate-good-points = js-generate-good-points"
    (let [extent {:width 100 :height 100}
          n 1000]
      (is (= (js->clj
               (js-generate-good-points (make-srng 1) n (clj->js extent)))
             (generate-good-points (make-srng 1) n extent))))))


;; --- make-mesh
;; This takes a bunch of points and creates a mesh
;;
;; TODO: Change to using indexOf? (.indexOf [[3 1]] [3 1]) instead of contains? + set
(defn js-make-mesh [pts extent]
  (.makeMesh terrain pts extent))

(defn add-id+conj [{:keys [vxs] :as state} point]
  (-> state
    (assoc-in [:vxids point] (count vxs))
    (update :vxs conj point)))

(defn add-adj [{:keys [vxids] :as state} left right]
  (let [left-idx  (get vxids left)
        right-idx (get vxids right)]
    (-> state
      (update-in [:adj left-idx]  (fnil conj []) right-idx)
      (update-in [:adj right-idx] (fnil conj []) left-idx))))

(defn add-edge [{:keys [vxids] :as state} edge]
  (let [[left right] edge
        [left' right']  [(js->clj left) (js->clj right)]
        left-idx (get vxids left')
        right-idx (get vxids right')
        left-edge  (.-left edge)
        right-edge (.-right edge)]
    (update state :edges (fnil conj []) [left-idx right-idx left-edge right-edge])))

(defn add-triangles [{:keys [vxids tris] :as state} edge]
  (let [[left right] edge
        [left' right']  [(js->clj left) (js->clj right)]
        left-idx (get vxids left')
        right-idx (get vxids right')
        left-edge  (.-left edge)
        right-edge (.-right edge)]
    (cond-> state
      (not (contains? (set (get tris left-idx)) left-edge))
      (update-in [:tris left-idx] (fnil conj []) left-edge)

      (and right-edge (not (contains? (set (get tris left-idx)) right-edge)))
      (update-in [:tris left-idx] (fnil conj []) right-edge)

      (not (contains? (set (get tris right-idx)) left-edge))
      (update-in [:tris right-idx] (fnil conj []) left-edge)

      (and right-edge (not (contains? (set (get tris right-idx)) right-edge)))
      (update-in [:tris right-idx] (fnil conj []) right-edge))))

(defn make-mesh
  ([points] (make-mesh points default-extent))
  ([points extent]
   (let [voronoi-state (voronoi points extent)
         extracted-state (extract-voronoi voronoi-state)
         voronoi-edges (.-edges voronoi-state)]
     (reduce
       (fn [{:keys [vxids vxs] :as mesh-state} edge]
         (if-let [[left right] edge]
           (let [[left' right']  [(js->clj left) (js->clj right)]
                 left-idx (get vxids left')
                 right-idx (get vxids right')]
             (-> (cond-> mesh-state

                   (nil? left-idx)
                   (add-id+conj left')

                   (nil? right-idx)
                   (add-id+conj right'))
               (add-adj left' right')
               (add-edge edge)
               (add-triangles edge)))
           mesh-state))
       {:points  points
        :voronoi voronoi-state
        :extent  extent
        :vxs   []
        :vxids {}
        :adj   []
        :edges []
        :tris  []}
       voronoi-edges))))


(defn extract-mesh [mesh-state]
  (let [vxs (:vxs mesh-state)
        vxids (:vxids mesh-state)
        adj (:adj mesh-state)
        tris (:tris mesh-state)
        edges (:edges mesh-state)
        extent (:extent mesh-state)]
    {:points (:points mesh-state)
     :voronoi (extract-voronoi (:voronoi mesh-state))
     :vxs (js->clj vxs)
     :adj (js->clj adj)
     :tris (js->clj tris)
     :edges (js->clj edges)
     :extent (js->clj extent :keywordize-keys true)}))

(defn extract-js-mesh [js-mesh-state]
  (let [points (.-pts js-mesh-state)
        voronoi (.-vor js-mesh-state)
        vxs (.-vxs js-mesh-state)
        adj (.-adj js-mesh-state)
        tris (.-tris js-mesh-state)
        edges     (.-edges js-mesh-state)
        extent (.-extent js-mesh-state)]
    {:points (js->clj points)
     :voronoi (extract-voronoi voronoi)
     :vxs (js->clj vxs)
     :adj  (js->clj adj)
     :tris (js->clj tris)
     :edges (js->clj edges)
     :extent (js->clj extent :keywordize-keys true)}))


(deftest make-mesh-test
  (testing "Check that make-mesh = js-make-mesh"
    (let [extent {:width 100 :height 100}
          points (generate-good-points (make-srng 1) 1000 extent)]
      (is (= (js->clj
               (extract-js-mesh (js-make-mesh (clj->js points) (clj->js extent))))
            (extract-mesh (make-mesh points extent)))))))


;; --- generate-good-mesh
;; This makes a better mesh by using generate-good-points
;;
;; TODO: Same as before, made a functional version
(defn js-generate-good-mesh1 [n extent]
  (.generateGoodMesh terrain n extent))

(defn js-generate-good-mesh [rand n extent]
  (.generate_good_mesh terrain rand n extent))

(defn generate-good-mesh
  ([rng n] (generate-good-mesh rng n default-extent))
  ([rng n extent]
   (let [points (generate-good-points rng n extent)]
     (make-mesh points extent))))

(deftest generate-good-mesh-test
  (testing "Check that generate-good-mesh = js-generate-good-mesh"
    (let [extent {:width 100 :height 100}
          n 1000]
      (is (= (js->clj
               (extract-js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))))
            (extract-mesh (generate-good-mesh (make-srng 1) n extent)))))))


;; --- edge-idx?
;; This checks if index given is on the edge, by looking at the adjacency graph
;;
(defn js-edge-idx? [mesh idx]
  (.isedge terrain mesh idx))

(defn edge-idx? [{:keys [adj] :as _mesh} idx]
  (< (count (nth adj idx)) 3))

(deftest edge-idx?-test
  (testing "Check that for a given mesh edge-idx? = js-edge-idx?"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          mesh (js->clj (extract-js-mesh js-mesh))
          edges (:edges mesh)]
      (is (= (map (fn [[left-idx right-idx _ _]]
                    [(js-edge-idx? js-mesh left-idx) (js-edge-idx? js-mesh right-idx)]) edges)
             (map (fn [[left-idx right-idx _ _]]
                    [(edge-idx? mesh left-idx) (edge-idx? mesh right-idx)]) edges))))))


;; --- near-edge-idx?
;; This checks if the point at the index given is near the edge, by checking it's distance from it
;;
(defn js-near-edge-idx? [mesh idx]
  (.isnearedge terrain mesh idx))

(defn near-edge-idx? [{:keys [vxs extent] :as mesh} idx]
  (let [[x y] (nth vxs idx)
        {:keys [width height]} extent]
    (or
      (< x (* -0.45 width))
      (> x (*  0.45 width))
      (< y (* -0.45 height))
      (> y (*  0.45 height)))))

(deftest near-edge-idx?-test
  (testing "Check that for a given mesh near-edge-idx? = near-edge-idx?"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          mesh (js->clj (extract-js-mesh js-mesh))
          edges (:edges mesh)]
      (is (= (map (fn [[left-idx right-idx _ _]]
                    [(js-near-edge-idx? js-mesh left-idx) (js-near-edge-idx? js-mesh right-idx)]) edges)
             (map (fn [[left-idx right-idx _ _]]
                    [(near-edge-idx? mesh left-idx) (near-edge-idx? mesh right-idx)]) edges))))))


;; --- neighbour-idxs
;; This gives us the indexes of the points at the index given
;;
(defn js-neighbour-idxs [mesh idx]
  (.neighbours terrain mesh idx))

(defn neighbour-idxs [{:keys [adj] :as mesh} idx]
  (let [nbs (nth adj idx)]
    nbs))

(deftest neighbour-idxs-test
  (testing "Check that for a given mesh neighbour-idxs = js-neighbour-idxs"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          mesh (js->clj (extract-js-mesh js-mesh))
          edges (:edges mesh)]
      (is (= (js->clj
               (map (fn [[left-idx right-idx _ _]]
                      [(js-neighbour-idxs js-mesh left-idx) (js-neighbour-idxs js-mesh right-idx)]) edges))
             (map (fn [[left-idx right-idx _ _]]
                    [(neighbour-idxs mesh left-idx) (neighbour-idxs mesh right-idx)]) edges))))))


;; --- distance
;; This computes the distance between two points at the given indexes
;;
(defn js-distance [mesh a-idx b-idx]
  (.distance terrain mesh a-idx b-idx))

(defn distance [{:keys [vxs] :as _mesh} a-idx b-idx]
  (let [[ax ay] (nth vxs a-idx)
        [bx by] (nth vxs b-idx)]
    (Math/sqrt (+ (* (- ax bx)
                     (- ax bx))
                  (* (- ay by)
                     (- ay by))))))

(deftest distance-test
  (testing "Check that for a given mesh distance = js-distance"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          mesh (js->clj (extract-js-mesh js-mesh))
          edges (:edges mesh)]
      (is (= (js->clj
               (map (fn [[left-idx right-idx _ _]]
                      (js-distance js-mesh left-idx right-idx)) edges))
             (map (fn [[left-idx right-idx _ _]]
                    (distance mesh left-idx right-idx)) edges))))))


;; --- zero
;; This gives us a flat heightmap of the correct size
;;
(defn js-zero [mesh]
  (.zero terrain mesh))

(defn zero [{:keys [vxs] :as _mesh}]
  (vec (for [_i vxs] 0)))

(deftest zero-test
  (testing "Check that for a given mesh zero = js-zero"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          mesh (js->clj (extract-js-mesh js-mesh))]
      (is (= (js->clj
               (js-zero js-mesh))
            (zero mesh))))))


;; --- quantile
;; - Takes a height-map and gives the quantile at some numeric value, so if q is 0.5, that's the median,
;;   the first quartile at p = 0.25, and the third quartile at p = 0.75
;;
(defn js-quantile [height-map q]
  (.quantile terrain height-map q))

(defn quantile [height-map q]
  (let [size (count height-map)]
    (cond
      (or
        (<= q 0)
        (< size 2)) (apply min height-map)

      (>= q 1) (apply max height-map)

      :else
      (let [i  (* q (dec size))
            i0 (Math/floor i)
            sorted-height-map (if (sorted? height-map) height-map (sort height-map))
            value0 (apply max (take (inc i0) sorted-height-map))
            value1 (apply min (drop (inc i0) sorted-height-map))]
        (+ value0
           (* (- value1 value0) (- i i0)))))))

(deftest quantile-test
  (testing "Check that for a given mesh quantile = js-quantile"
    (let [n 1000
          hm (repeatedly n rand)
          p (rand-nth [0 0.25 0.5 0.75 1 (rand)])]
      (is (= (js->clj
               (js-quantile (clj->js hm) p))
             (quantile hm p))))))


;; --- slope
;; This generates a random slope, for creating ridge and fault lines, similar to what's created by uplifting tectonic plates.
;;
(defn js-slope [mesh direction]
  (.slope terrain mesh direction))

(defn slope [{:keys [vxs] :as _mesh} direction]
  (let [[dir-x dir-y] direction]
    (into [] (map (fn [[x y]]
                    (+ (* x dir-x)
                       (* y dir-y)))) vxs)))

(deftest slope-test
  (testing "Check that for a given mesh slope = js-slope"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          mesh (js->clj (extract-js-mesh js-mesh))
          _ (reset! z2 nil)
          rand-vector (random-vector (make-srng 1) 4)]
      (is (= (js->clj
               (js-slope js-mesh (clj->js rand-vector)))
             (slope mesh rand-vector))))))


;; --- cone
;; This generates a random cone, useful for creating islands or mountains, or if inverted, lakes or seas.
;;
(defn js-cone [mesh slope]
  (.cone terrain mesh slope))

(defn cone [{:keys [vxs] :as _mesh} slope]
  (into [] (map (fn [[x y]]
                  (* (Math/pow (+ (* x x) (* y y))
                       0.5)
                     slope))) vxs))

(deftest cone-test
  (testing "Check that for a given mesh cone = js-cone"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          mesh (js->clj (extract-js-mesh js-mesh))
          rng (make-srng 1)
          rand-slope (run-if rng -1 -1)]
      (is (= (js->clj
               (js-cone js-mesh (clj->js rand-slope)))
             (cone mesh rand-slope))))))


;; --- apply-hm
;; I wanted to skip this, because map is just map, but then I realised that my first refactor will probably have the
;;   height-map inside or alongside the mesh, so I'll keep it for now, if it becomes redundant, I can always remove it.
;;
(defn js-apply-hm [height-map f]
  (.map terrain height-map f))

(defn apply-hm [height-map f]
  (into [] (map f) height-map))

(deftest apply-hm-test
  (testing "Check that for a given height-map apply-hm = js-apply-hm"
    (let [n 1000
          hm (vec (repeatedly n rand))
          f #(if (< 0.5 %) 1 0)]
      (is (= (js->clj
               (js-apply-hm (clj->js hm) f))
             (apply-hm hm f))))))


;; --- normalise
;; Basically proportionally compute the values to be between 0 and 1
;;
(defn js-normalise [height-map]
  (.normalize terrain height-map))

(defn normalise [height-map]
  (let [low  (apply min height-map)
        high (apply max height-map)]
    (into [] (map (fn [h]
                    (/ (- h low) (- high low)))) height-map)))

(deftest normalise-test
  (testing "Check that for a given height-map normalise = js-normalise"
    (let [n 1000
          hm (vec (repeatedly n rand))]
      (is (= (js->clj
               (js-normalise (clj->js hm)))
             (normalise hm))))))


;; --- peaky
;; Basically normalises the height-map and then takes the square root of each height
;;
(defn js-peaky [height-map]
  (.peaky terrain height-map))

(defn peaky [height-map]
  (-> height-map
    (normalise)
    (apply-hm #(Math/sqrt %))))

(deftest peaky-test
  (testing "Check that for a given height-map peaky = js-peaky"
    (let [n 1000
          hm (repeatedly n rand)]
      (is (= (js->clj
               (js-peaky (clj->js hm)))
             (peaky hm))))))


;; --- add
;; Takes a bunch of height-maps and elementwise adds them together
;;
(defn js-add [hms]
  (apply (partial (.-add terrain)) hms))

(defn add [hms]
  (let [size (count hms)]
    (->> hms
      (apply interleave)
      (into [] (comp (partition-all size) (map #(reduce + 0 %)))))))

(deftest add-test
  (testing "Check that for a given list of height-maps add = js-add"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          _ (reset! z2 nil)
          rand-vector (random-vector (make-srng 1) 4)
          hms [(js-slope js-mesh (clj->js rand-vector))]]
      (is (= (js->clj
               (js-add hms))
             (add (js->clj hms)))))))


;; --- mountains
;; Takes a bunch of height-maps and elementwise adds them together
;;
;; TODO: Same as before, made a functional version
(defn js-mountains1 [rng mesh n r]
  (.mountains terrain mesh n r))

(defn js-mountains [rng mesh n r]
  (.functional_mountains terrain rng mesh n r))

(defn mountains
  ([rng mesh n] (mountains rng mesh n 0.05))
  ([rng {:keys [vxs extent] :as mesh} n r]
   (let [locations (generate-points rng n extent)]
     (mapv
       (fn [[vx vy]]
         (reduce
           (fn [cur [mx my]]
             (+ cur (Math/pow
                      (Math/exp
                        (/ (- (+ (* (- vx mx) (- vx mx))
                                (* (- vy my) (- vy my))))
                          (* 2 r r)))
                      2)))
           0
           locations))
       vxs))))

(deftest mountains-test
  (testing "Check that for a given mesh mountains = js-mountains"
    (let [extent {:width 100 :height 100}
          n 1000
          r 50
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          mesh (js->clj (extract-js-mesh js-mesh))]
      (is (= (js->clj
               (js-mountains (make-srng 1) js-mesh n r))
             (mountains (make-srng 1) mesh n r))))))


;; --- relax
;; Smooths the height-map by averaging over the values of element neighbours
;;
(defn js-relax [mesh height-map]
  (.relax terrain height-map))

(defn mean [xs]
  (/ (reduce + xs) (count xs)))

(defn relax [mesh height-map]
  (reduce-kv
    (fn [hm idx _h]
      (let [nbs (neighbour-idxs mesh idx)]
        (if (< (count nbs) 3)
          (conj hm 0)
          (conj hm (mean (map (fn [h-idx] (nth height-map h-idx)) nbs))))))
    []
    height-map))

(deftest relax-test
  (testing "Check that for a given mesh and height-map relax = js-relax"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          _ (reset! z2 nil)
          rand-vector (random-vector (make-srng 1) 4)
          hms [(js-slope js-mesh (clj->js rand-vector))]
          js-hm (js-add hms)
          js-mesh' (.-mesh js-hm)
          mesh (js->clj (extract-js-mesh js-mesh'))]
      (is (= (js->clj
               (js-relax js-mesh js-hm))
             (relax mesh (js->clj js-hm)))))))


;; --- downhill
;; For every element of the heightmap, find the neighbouring-idx that goes down
;;
(defn js-downhill [mesh height-map]
  (.downhill terrain height-map))

(defn down-from [mesh height-map idx]
  (if (edge-idx? mesh idx)
    -2
    (-> (let [best -1
              best-height (nth height-map idx)
              nbs (neighbour-idxs mesh idx)]
          (reduce
            (fn [state neighbour-idx]
              (let [[best best-height] state
                    height (nth height-map neighbour-idx)]
                (if (< height best-height)
                  [neighbour-idx height]
                  state)))
            [best best-height]
            nbs))
      (first))))

(defn downhill [mesh height-map]
  (reduce-kv
    (fn [hm idx _h]
      (conj hm (down-from mesh height-map idx)))
    []
    height-map))

(deftest downhill-test
  (testing "Check that for a given mesh and height-map downhill = js-downhill"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          _ (reset! z2 nil)
          rand-vector (random-vector (make-srng 1) 4)
          hms [(js-slope js-mesh (clj->js rand-vector))]
          js-hm (js-add hms)
          js-mesh' (.-mesh js-hm)
          mesh (js->clj (extract-js-mesh js-mesh'))]
      (is (= (js->clj
               (js-downhill js-mesh js-hm))
             (downhill mesh (js->clj js-hm)))))))


;; --- find-sinks
;; Find the location-idxs of the height-map that are their lowest respective points
;;
(defn js-find-sinks [mesh height-map]
  (.findSinks terrain height-map))

(defn find-sinks [mesh height-map]
  (let [down-hill (downhill mesh height-map)]
    (reduce-kv
      (fn [sinks idx _down-hill-val]
        (conj sinks
          (loop [i  idx]
            (let [dh (nth down-hill i)]
              (cond
                (edge-idx? mesh i) -2
                (= dh -1)          i
                :else (recur dh))))))
      []
      down-hill)))

(deftest find-sinks-test
  (testing "Check that for a given mesh and height-map find-sinks = js-find-sinks"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          _ (reset! z2 nil)
          rand-vector (random-vector (make-srng 1) 4)
          hms [(js-slope js-mesh (clj->js rand-vector))]
          js-hm (js-add hms)
          js-mesh' (.-mesh js-hm)
          mesh (js->clj (extract-js-mesh js-mesh'))]
      (is (= (js->clj
               (js-find-sinks js-mesh js-hm))
             (find-sinks mesh (js->clj js-hm)))))))


;; --- fill-sinks
;; Take the lowest points of the heightmap and slowly fill them to be in line with their immediate neighbours
;;
(defn js-fill-sinks [mesh height-map epsilon]
  (.fillSinks terrain height-map epsilon))

(defn fill-step [mesh height-map new-height-map epsilon]
  (into []
       (map (fn [[idx height new-height]]
              (if (= height new-height)
                height
                (let [nbs (neighbour-idxs mesh idx)]
                  (reduce
                    (fn [state neighbour-idx]
                      (let [inc'd-height (+ (nth new-height-map neighbour-idx) epsilon)]
                        (cond
                          (>= height inc'd-height)
                          (reduced height)
                          (and (> new-height inc'd-height)
                            (> inc'd-height height))
                          inc'd-height
                          :else
                          state)))
                    new-height
                    nbs)))))
       (partition-all 3 (interleave (range) height-map new-height-map))))

(defn fill-sinks
  ([mesh height-map] (fill-sinks mesh height-map 1e-5))
  ([mesh height-map epsilon]
   (let [new-height-map (reduce-kv
                          (fn [new-hm idx height]
                            (conj new-hm (if (near-edge-idx? mesh idx) height ##Inf)))
                          []
                          height-map)]
     (loop [new-hm new-height-map]
       (let [step (fill-step mesh height-map new-hm epsilon)]
         (if (= new-hm step)
           new-hm
           (recur step)))))))

(deftest fill-sinks-test
  (testing "Check that for a given mesh and height-map fill-sinks = js-fill-sinks"
    (let [extent {:width 100 :height 100}
          n 1000
          epsilon 1e-5
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          _ (reset! z2 nil)
          rand-vector (random-vector (make-srng 1) 4)
          hms [(js-slope js-mesh (clj->js rand-vector))]
          js-hm (js-add hms)
          js-mesh' (.-mesh js-hm)
          mesh (js->clj (extract-js-mesh js-mesh'))]
      (is (= (js->clj
               (js-fill-sinks js-mesh js-hm epsilon))
             (fill-sinks mesh (js->clj js-hm) epsilon))))))


;; --- get-flux
;; Find the locations of the height-map that are their lowest respective points
;;
(defn js-get-flux [_mesh height-map]
  (.getFlux terrain height-map))

(defn vec-by-idx [v]
  (into {} (map-indexed (fn [idx v] [idx v])) v))

(defn get-flux [mesh height-map]
  (let [down-hill (downhill mesh height-map)
        flux-val (/ 1 (count height-map))
        flux (mapv (fn [_height] flux-val) height-map)
        sorted-hm-by-idx (->> (vec-by-idx height-map)
                           (sort (fn [[_idx-a height-a] [_idx-b height-b]] (- height-b height-a)))
                           (vec))]
    (reduce-kv
      (fn [flux idx _height]
        (let [[nth-height-idx _nth-height] (nth sorted-hm-by-idx idx)
              dh-idx (nth down-hill nth-height-idx)]
          (if (>= dh-idx 0)
            (update flux dh-idx + (nth flux nth-height-idx))
            flux)))
      flux
      height-map)))

(deftest get-flux-test
  (testing "Check that for a given mesh and height-map get-flux = js-get-flux"
    (let [extent {:width 100 :height 100}
          n 1000
          js-mesh (js-generate-good-mesh (make-srng 1) n (clj->js extent))
          _ (reset! z2 nil)
          rand-vector (random-vector (make-srng 1) 4)
          hms [(js-slope js-mesh (clj->js rand-vector))]
          js-hm (js-add hms)
          js-mesh' (.-mesh js-hm)
          mesh (js->clj (extract-js-mesh js-mesh'))]
      (is (= (js->clj
               (js-get-flux js-mesh js-hm))
             (get-flux mesh (js->clj js-hm)))))))
